{% extends "templates/base.html" %}

{% load static %}

{% block page_content %}

<script src="{% static 'js/ol.js' %}"></script>
<link rel="stylesheet" href="{% static 'css/ol.css' %}" type="text/css">

<script src="{% static 'boundaryBuilder/js/internalSpatial.js' %}"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/4.7.3/turf.min.js"></script>

<style>
    #main-section {
        display:flex;
        flex-direction:row;
        gap:10px;
        width:100%;
    }

    #queries-div {
        display: flex;
        flex-direction: row;
        gap: 10px;
    }
    
    .query {
        background-color: lightgray;
        border-radius: 10px;
        padding: 5px;
        min-width: 40px;
        text-align: center;
    }

    #map-div {
        width:100%;
    }
    
    #map {
        width: 100%; 
        height: 400px;
    }

    #sidepanel {
        width:100%;
        height:400px;
    }
    #info-div {
        height:100%;
        margin-bottom:5px;
    }

    #info-div ul {
        list-style-type: none;
    }

    #info-div ul li {
        margin-top: 20px;
    }

    #info-div ul li img {
        height: 25px;
    }

    .timespan {
        position:absolute;
        background-color:#F0B323; 
        color: white;
        border-radius:5px; 
        padding:10px;
        text-align:center;
        transform:translate(-50%, -100%)%;
        height:41px;
        overflow:hidden;
    }
    .timespan-content {
        display:flex; 
        flex-direction:row; 
        align-items:center; 
        width:100%;
    }
    .timespan:hover {
        cursor:pointer;
    }
    .timespan-current {
        background-color:skyblue; 
        color: white;
        height:100%;
    }
    .timespan-filler {
        color: white;
        border-radius:15px; 
        padding:10px;
        height:41px;
        overflow:hidden;
    }
    .timespan-label {
        margin-right:5px; 
        margin-left:5px;
        vertical-align:middle; 
        white-space:nowrap; 
        overflow:hidden;
    }

    #current-date {
        position:absolute; 
        top:0%; 
        width:5px;
        height:100%;
    }

    #current-date-content {
        background-color:rgb(189, 223, 236); 
        width:100%; 
        height:100%;
        text-align:center; 
        font-weight:bold; 
        font-style:italic;
    }

    #date-labels-div {
        width:100%; 
        background-color:gray;
    }

    .date-label {
        position:absolute; 
        width:fit-content; 
        text-align:center; 
        transform:translate(-50%, -100%);
    }

    .date-label-line {
        position:absolute;  
        top:0%; 
        height:100%; 
        width:1px; 
        background-color:rgb(200,200,200);
    }

    /* changes */
    .change-list {
        margin: 0px;
    }

    .change-entry {
        width: 97%;
        display: flex;
        flex-direction: row;
        margin: 5px;
    }

    .change-type {
        width: 20%;
        background-color: #F0B323;
        color: white;
        border-radius: 5px;
        padding: 3px;
    }

    .change-from {
        width: 40%;
        background-color: lightgray;
        border-radius: 5px;
        padding: 3px;
    }
    .change-to {
        width: 40%;
        background-color: lightgray;
        border-radius: 5px;
        padding: 3px;
    }

</style>

<section>
    <div class="content">
        <header>
            <div id="queries-div">
                <h2>Build-Your-Own-Boundary: </h2>
                {% for name in names %}
                    <h3 class="query">{{ name }}</h3>
                {% endfor %}
            </div>
        </header>

        <div id="main-section">
            <div id="map-div">
                <div id="map"></div>
            </div>
            <div id="sidepanel">
                <div id="info-div" class="box">
                    <div class="row"><img height="30px" src="{% static 'images/time.svg' %}"><h3><span id="timeperiod">XXXX-XX-XX</span></h3></div>
                    <div id="events-div" style="margin-left:0px; height:79%; overflow:auto">
                        Initializing... 
                        <!--
                        <div class="change-list">
                            <div class="change-entry">
                                <span class="change-type">Transfer</span>
                                <span class="change-from">From</span>
                                <span class="change-to">To</span>
                                <span><button class="button small">Show</button></span>
                            </div>
                            <div class="change-entry">
                                <span class="change-type">Transfer</span>
                                <span class="change-from">From</span>
                                <span class="change-to">To</span>
                                <span><button class="button small">Show</button></span>
                            </div>
                        </div>
                        -->
                    </div>
                    <div style="display:flex; flex-direction:row; width:100%; justify-content:space-between">
                        <button id="prev-button" onclick="prevDate()">Previous</button>
                        <button id="next-button" onclick="nextDate()">Next</button>
                    </div>
                </div>
            </div>
        </div>

    </div>
    
    <div id="timeline">
        <div id="timeline-data" style="width:93%; min-height:80px; margin:6% 3.5%; position:relative; background-color:whitesmoke; border:rgb(200,200,200) 1px solid">
            <!-- tick date labels -->
            <div class="date-labels-div">
                {% for tick in ticks %}
                <div class="date-label" style="left:{{ tick.percent }}%; right:{{ tick.percent }}%">{{ tick.label }}</div>
                {% endfor %}
            </div>

            <!-- vertical lines at tick dates -->
            {% for tick in ticks %}
                <div style="left:{{ tick.percent }}%; right:{{ tick.percent }}%">
                </div>
            {% endfor %}

            <!-- current time marking (needs to be set with left=...) -->
            <div id="current-date">
                <div id="current-date-content">CURRENT</div>
            </div>

            <!-- all event timespans -->
            <br>
            {% for event in events %}
                <div class="timespan" style="left:{{ event.date_start_perc }}%; width:{{ event.date_dur_perc }}%" title="{{ event.date_start }} &rarr; {{ event.date_end }}">
                    <div class="timespan-content">
                        <img height="20px" src="{% static 'images/time.svg' %}" style="filter:invert(1); vertical-align:middle"/>
                        <span class="timespan-label">
                            Event info... 
                        </span>
                    </div>
                </div>
                <div class="timespan-filler">
                    <!-- since timespans are absolute, need relative divs to fill up the height -->
                </div>
                <br>
            {% endfor %}
        </div>
    </div>

</section>

<br><br>

<script>
    /////////////
    // main map

    // styling
    function getLargestGeom(feature) {
        // create a geometry that defines where the label will be display
        var geom = feature.getGeometry();
        if (geom.getType() == 'Polygon') {
            // polygon
            // place label at the bbox/center of the polygon
            var extent = feature.getGeometry().getExtent();
            var newGeom = ol.geom.Polygon.fromExtent(extent);
        } else {
            // multi polygon
            // place label at the bbox/center of the largest polygon
            var largestGeom = null;
            var largestArea = null;
            for (poly of geom.getPolygons()) {
                var extent = poly.getExtent();
                var extentGeom = ol.geom.Polygon.fromExtent(extent);
                var extentArea = extentGeom.getArea();
                if (extentArea > largestArea) {
                    largestGeom = extentGeom;
                    largestArea = extentArea;
                };
            };
            var newGeom = largestGeom;
            
        };
        return newGeom;
    };

    var mainStyle = new ol.style.Style({
        fill: new ol.style.Fill({
            color: 'rgba(220, 220, 255, 0.5)'
        }),
        stroke: new ol.style.Stroke({
            color: 'rgb(29,107,191)',
            width: 2
        })
    });

    var comparisonStyle = new ol.style.Style({
        fill: new ol.style.Fill({
            color: 'rgba(255, 255, 255, 0)', // fully transparent
        }),
        stroke: new ol.style.Stroke({
            color: 'rgba(0, 155, 0, 0.8)',
            width: 1.5,
            lineDash: [10,10]
        }),
    });

    var highlightStyle = new ol.style.Style({
        fill: new ol.style.Fill({
            color: 'rgba(255, 0, 0, 0.5)',
        }),
        stroke: new ol.style.Stroke({
            color: 'rgba(255, 0, 0, 1)',
            width: 3
        }),
    });

    var textStyle = new ol.style.Style({
        text: new ol.style.Text({
            font:'15px sans-serif',
            overflow:true,
            stroke: new ol.style.Stroke({
                color: 'rgb(255,255,255)',
                width: 2
            })
        }),
        geometry: getLargestGeom
    });

    function mainGetStyle(feature) {
        let _textStyle = textStyle.clone();
        // set name label
        let name = feature.get('fields').names[0].fields.name; // ignore alt names
        _textStyle.getText().setText(name);
        return [mainStyle, _textStyle];
    };

    // layer
    var mainLayer = new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: mainGetStyle,
    });

    var comparisonLayer = new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: comparisonStyle,
    });

    var highlightLayer = new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: highlightStyle,
    });

    // map
    var map = new ol.Map({
        target: 'map',
        controls: ol.control.defaults().extend([new ol.control.FullScreen(),
                                                new ol.control.ScaleLine({units: 'metric'}),
                                                ]),
        layers: [
        new ol.layer.Tile({
            source: new ol.source.XYZ({
                attributions: 'Satellite Imagery from Google',
                url:
                'http://mt0.google.com/vt/lyrs=s&hl=en&x={x}&y={y}&z={z}',
                maxZoom: 20,
                crossOrigin: 'anonymous' // necessary for converting map to img during pdf generation: https://stackoverflow.com/questions/66671183/how-to-export-map-image-in-openlayer-6-without-cors-problems-tainted-canvas-iss
            })}),
            mainLayer,
            comparisonLayer,
            highlightLayer
        ],
        view: new ol.View({
            center: ol.proj.fromLonLat([0,0]),
            zoom: 1
        })
    });

</script>



<script>
    function getMapData() {
        queryString = window.location.search;
        queryString += '&model=changeManager.BoundarySnapshot';
        url = "{% url 'api_filter' %}" + queryString;
        console.log(url)
        fetch(url).then(resp=>resp.json()).then(data=>mapInit(data));
    };

    function boundaryReferenceToProperties(boundaryRef) {
        return boundaryRef;
    };

    function snapshotsToGeoJSON(data) {
        coll = {type:'FeatureCollection', features:[]}
        for (snap of data) {
            geom = snap.fields.geom;
            props = boundaryReferenceToProperties(snap.fields.boundary_ref);
            feat = {type:'Feature', geometry:geom, properties:props, id:props.pk};
            coll.features.push(feat);
        };
        return coll;
    };

    function GeoJSONToFeatures(coll) {
        feats = new ol.format.GeoJSON().readFeatures(coll, {dataProjection: 'EPSG:4326', featureProjection: 'EPSG:3857'});
        return feats;
    };

    function mapInit(data) {
        console.log(data)
        coll = snapshotsToGeoJSON(data);
        window.mainData = coll;
        feats = GeoJSONToFeatures(coll);
        mainLayer.getSource().addFeatures(feats);
        map.getView().fit(mainLayer.getSource().getExtent());
    };

    // init
    getMapData();
</script>



<script>
    // boundary comparison stuff
    function getSnapshotsAtDate(date) {
        // define url
        urlParams = new URLSearchParams(window.location.search);
        queryString = '?model=changeManager.BoundarySnapshot';
        for (key of urlParams.keys()) {
            if (key.endsWith('_source')) {continue};
            val = urlParams.get(key);
            queryString += `&${key}=${val}`;
        };
        queryString += '&event__date_start__lte='+date;
        queryString += '&event__date_end__gte='+date;
        url = "{% url 'api_filter' %}" + queryString;
        console.log(url);
        // init loading lock
        loadingLock();
        resetData();
        // get snapshots
        fetch(url).then(resp=>resp.json()).then(data=>snapshotsLoaded(data));
    };

    function snapshotsLoaded(data) {
        coll = snapshotsToGeoJSON(data);
        setComparisonLayer(coll);
        boundaryCompare(coll);
        updateNavButtons(dates[currentDateIndex]);
    };

    function loadingLock() {
        document.getElementById('prev-button').disabled = true;
        document.getElementById('next-button').disabled = true;
    };

    function resetData() {
        // map layers
        comparisonLayer.getSource().clear();
        highlightLayer.getSource().clear();
        // info table
        div = document.getElementById('events-div');
        div.innerHTML = 'Loading...'; // clear out
    };

    function setComparisonLayer(coll) {
        comparisonLayer.getSource().clear();
        feats = GeoJSONToFeatures(coll);
        comparisonLayer.getSource().addFeatures(feats);
    };

    // comparisons
    function boundaryCompare(coll) {
        console.log(coll);
        data1 = JSON.stringify(window.mainData);
        data2 = JSON.stringify(coll);
        calcAllSpatialRelations(data1, data2, onSuccess=onMatchesFound);
    };

    function onMatchesFound(results) {
        [feats1,feats2,matches] = results;
        bestMatches = calcBestMatches(matches);
        //console.log(bestMatches);
        // loop and process only those below x similarity
        changeData = [];
        highlightLayer.getSource().clear();
        for ([f1,related] of matches) {
            console.log('---');
            console.log(f1);
            related = sortSpatialRelations(related, 'equality', 0.01);
            // only process if best match < 0.95
            //if (related[0]['equality'] >= 0.95) { continue }; // almost no change
            // loop
            for ([f2,stats] of related.slice(1)) {
                console.log(stats);
                console.log(f2);
                // determine change entry
                changeType = 'Transfer';
                entry = {type:changeType,
                        from:f1.properties,
                        to:f2.properties,
                        id:changeData.length+1,
                        };
                changeData.push(entry);
                console.log(entry);
                // get features
                feat1 = mainLayer.getSource().getFeatureById(f1.properties.pk);
                feat2 = comparisonLayer.getSource().getFeatureById(f2.properties.pk);
                // calc diff
                try {
                    isec = geomIntersection(feat1, feat2);
                } catch(err) {
                    console.log('geometry error: '+err);
                    continue;
                };
                if (isec == null) {
                    continue;
                };
                // add to map
                feat = new ol.format.GeoJSON().readFeature(isec);
                feat.setId(entry.id);
                highlightLayer.getSource().addFeature(feat);
            };
        };
        /*
        for ([f1,f2,stats] of bestMatches) {
            if (stats.equality < 0.95) {
                console.log(stats);
                console.log(f2);
                // determine change entry
                changeType = 'Transfer';
                entry = {type:changeType,
                        from:f1.properties,
                        to:f2.properties};
                changeData.push(entry);
                // get features
                feat1 = mainLayer.getSource().getFeatureById(f1.properties.pk);
                feat2 = comparisonLayer.getSource().getFeatureById(f2.properties.pk);
                // calc diff
                try {
                    diff = geomDifference(feat1, feat2);
                } catch(err) {
                    console.log('geometry error: '+err);
                    continue;
                };
                if (diff == null) {
                    continue;
                };
                // add to map
                feat = new ol.format.GeoJSON().readFeature(diff);
                highlightLayer.getSource().addFeature(feat);
            };
        };
        */
        // show changes in list
        addSuggestedChanges(changeData);
    };

    function zoomToFeat(lyr, id) {
        feat = lyr.getSource().getFeatureById(id);
        map.getView().fit(feat.getGeometry().getExtent(),
                          {'duration':500, 'padding':[10,10,10,10]}
        );
    };

    function addSuggestedChanges(changeData) {
        // add list of each detected change event in the right panel
        div = document.getElementById('events-div');
        div.innerHTML = ''; // clear out
        if (changeData.length == 0) {
            div.innerHTML = 'No changes detected for this date';
        } else {
            // add header
            div.innerHTML = `
            <div class="row" style="width:95%">
                <span style="width:20%">Type</span>
                <span style="width:40%">From</span>
                <span style="width:40%">To</span>
            </div>
            `
        };
        // loop
        changeEntries = document.createElement('div');
        changeEntries.className = 'change-list';
        div.appendChild(changeEntries);
        for (change of changeData) {
            //console.log(change);
            // entry
            entry = document.createElement('div');
            entry.className = 'change-entry';
            changeEntries.appendChild(entry);
            // type
            obj = document.createElement('span');
            obj.className = 'change-type';
            obj.innerText = change.type;
            entry.appendChild(obj);
            // from
            obj = document.createElement('span');
            obj.className = 'change-from';
            obj.innerText = change.from.fields.names[0].fields.name;
            entry.appendChild(obj);
            // to
            obj = document.createElement('span');
            obj.className = 'change-to';
            obj.innerText = change.to.fields.names[0].fields.name;
            entry.appendChild(obj);
            // buttons div
            obj = document.createElement('div');
            entry.appendChild(obj);
            // zoom button
            obj = document.createElement('button');
            obj.className = 'button small';
            obj.innerText = 'Show';
            let id = change.id;
            obj.onclick = function() {zoomToFeat(highlightLayer, id)};
            entry.appendChild(obj);
        };
    };
</script>



<script>
    // save all events for future use
    events = [];
    {% for event in events %}
        event = {};
        event['date_start'] = "{{ event.date_start }}";
        event['date_end'] = "{{ event.date_end }}";
        events.push(event);
    {% endfor %}

    // turn into unique dates
    dates = {};
    for (event of events) {
        dates[event.date_start] = true;
        dates[event.date_end] = true;
    };
    dates = Object.keys(dates);

    // find total span in ms
    dates.sort();
    minDateNum = Date.parse(dates[0]);
    maxDateNum = Date.parse(dates[dates.length-1]);
    dateSpanNum = maxDateNum - minDateNum;
    
    // function to convert dates to percent
    function getDatePercent(date) {
        num = Date.parse(date);
        frac = (num - minDateNum) / dateSpanNum;
        return frac * 100.0;
    };

    // functions to set dates
    currentDateIndex = 0;
    
    function setCurrentDate(date) {
        perc = getDatePercent(date);
        document.getElementById('current-date').style.left = perc + '%';
        document.getElementById('timeperiod').innerText = date;
        updateNavButtons(date);
        getSnapshotsAtDate(date);
    };

    function prevDate() {
        currentDateIndex -= 1;
        date = dates[currentDateIndex];
        setCurrentDate(date);
    };

    function nextDate() {
        currentDateIndex += 1;
        date = dates[currentDateIndex];
        setCurrentDate(date);
    };

    // function to update navigation buttons
    function updateNavButtons(currentDate) {
        prevBut = document.getElementById('prev-button');
        nextBut = document.getElementById('next-button');
        // enable/disable previous button
        if (currentDate == dates[0]) {
            prevBut.disabled = true;
        } else {
            prevBut.disabled = false;
        };
        // enable/disable next button
        if (currentDate == dates[dates.length-1]) {
            nextBut.disabled = true;
        } else {
            nextBut.disabled = false;
        };
    };

    // init current date
    setCurrentDate(events[currentDateIndex]['date_start'])
</script>



<!--
JAVASCRIPT VERSION TO POPULATE TIMELINE (NOT FINISHED)

<script>
    function getAllDates() {
        urlParams = new URLSearchParams(window.location.search);
        queryString = '?model=changeManager.Event';
        for (key of urlParams.keys()) {
            if (key.endsWith('_source')) {continue};
            val = urlParams.get(key);
            key = 'snapshots__' + key; // queries boundary refs of an event's snapshots
            queryString += `&${key}=${val}`;
        };
        queryString += '&distinct=1'
        url = "{% url 'api_filter' %}" + queryString;
        console.log(url);
        fetch(url).then(resp=>resp.json()).then(data=>datesInit(data));
    };

    function datesInit(data) {
        console.log(data);
        // set things
        populateTimeline(data);
    };

    function populateTimeline(events) {
        // turn into unique dates
        dates = {};
        for (event of events) {
            dates[event.fields.date_start] = true;
            dates[event.fields.date_end] = true;
        };
        dates = Object.keys(dates);
        // find total span in ms
        dates.sort();
        minDateNum = Date.parse(dates[0]);
        maxDateNum = Date.parse(dates[dates.length-1]);
        dateSpanNum = maxDateNum - minDateNum;
        // timeline
        timelineDiv = document.getElementById('timeline-data');
        // tick date labels
        tickLabelsDiv = document.createElement('div');
        tickLabelsDiv.id = 'date-labels-div';
        function getTickPercent(date) {
            num = Date.parse(date);
            frac = (num - minDateNum) / dateSpanNum;
            return frac * 100.0;
        };
        function getTicks(dates) {
            dates.sort();
            minDateNum = Date.parse(dates[0]);
            maxDateNum = Date.parse(dates[dates.length-1]);
            dateSpanNum = maxDateNum - minDateNum;
            numTicks = 10;
            dateIncr = dateSpanNum / numTicks;
            for (let i=minDateNum; maxDateNum; i+dateIncr) {

            }
        }
        for (event of events) {
            label = document.createElement('div');
            label.className = 'date-label';
            label.style = `left:${perc}; right:${perc}`; // positions the label
        };
        timelineDiv.appendChild(tickLabelsDiv);

    // init
    getAllDates();
</script>

-->




<!--
<script>
    function getTrackData(names) {
        url = "{% url 'api_track' %}" + '?names=' + names[0];
        console.log(url);
        fetch(url).then(resp=>resp.json()).then(data=>trackDataLoaded(data));
    };

    function trackDataLoaded(data) {
        populateTrackData(data);
        populateTrackSources(data);
    };

    function populateTrackData(data) {
        console.log(data);
        div = document.getElementById('timeline-div');
        div.innerHTML = '';
        mapNum = 1;
        for (entry of data.entries) {
            entryDiv = document.createElement('div');
            entryDiv.className = "timeline-entry";
            div.appendChild(entryDiv);

            date = document.createElement('h3');
            date.className = "timeline-entry-date";
            valid_from = entry.valid_from.slice(0, 4);
            valid_to = entry.valid_to.slice(0, 4);
            date.innerText = `${valid_from} - ${valid_to}`;
            entryDiv.appendChild(date);

            content = document.createElement('div');
            content.className = "timeline-entry-content box";

            // dataset boundary snapshots
            if (entry.type == 'DataSource') {
                titleDiv = document.createElement('h4');
                titleDiv.className = "row";
                icon = document.createElement('img');
                icon.style = "height:20px"
                icon.src = "{% static 'images/dataset.png' %}";
                titleDiv.appendChild(icon);
                title = document.createElement('h4');
                sourceLink = `<a href="/source/${entry.source_id}">${entry.source}</a>`;
                title.innerHTML = `Boundary Snapshot from ${sourceLink}`;
                titleDiv.appendChild(title);
                content.appendChild(titleDiv);
                mapDiv = document.createElement('div');
                mapDiv.id = 'snapshot-map-' + mapNum;
                mapDiv.style = 'width:100%; height:300px';
                content.appendChild(mapDiv);
                details = document.createElement('span');
                details.innerHTML = `${entry.snapshots.length} Boundaries`;
                content.appendChild(details);
                entryDiv.appendChild(content);

                // create and load snapshot map
                createSnapshotMap(mapNum, entry.snapshots);

                mapNum += 1;
            };

            // map boundary snapshots
            if (entry.type == 'MapSource') {
                titleDiv = document.createElement('h4');
                titleDiv.className = "row";
                icon = document.createElement('img');
                icon.style = "height:20px"
                icon.src = "{% static 'images/map.png' %}";
                titleDiv.appendChild(icon);
                title = document.createElement('h4');
                sourceLink = `<a href="/source/${entry.source_id}">${entry.source}</a>`;
                title.innerHTML = `Map Snapshot from ${sourceLink}`;
                titleDiv.appendChild(title);
                content.appendChild(titleDiv);
                mapDiv = document.createElement('div');
                mapDiv.id = 'snapshot-map-' + mapNum;
                mapDiv.style = 'width:100%; height:300px';
                content.appendChild(mapDiv);
                details = document.createElement('span');
                details.innerHTML = `${entry.snapshots.length} Boundaries`;
                content.appendChild(details);
                entryDiv.appendChild(content);

                // create and load snapshot map
                createMapSourceMap(mapNum, entry.source_url, entry.snapshots);

                mapNum += 1;
            };
            
        };
    };

    function populateTrackSources(data) {
        valid_froms = [];
        valid_tos = [];
        for (entry of data.entries) {
            valid_froms.push(entry.valid_from);
            valid_tos.push(entry.valid_to);
        };
        valid_froms.sort();
        valid_from = valid_froms[0].slice(0, 4);
        valid_tos.sort();
        valid_to = valid_tos[valid_tos.length-1].slice(0, 4);
        document.getElementById('timeperiod').innerText = `${valid_from} - ${valid_to}`;
        document.getElementById('dataset_count').innerText = data.datasets.length;
        document.getElementById('map_count').innerText = data.maps.length;
        document.getElementById('text_count').innerText = data.texts.length;
    }

    function createSnapshotMap(mapId, snapshotIds) {
        // layer
        let snapshotLayer = new ol.layer.Vector({
            source: new ol.source.Vector(),
            style: mainGetStyle,
        });

        // map
        let map = new ol.Map({
            target: 'snapshot-map-' + mapId,
            controls: ol.control.defaults().extend([new ol.control.ScaleLine({units: 'metric'}),
                                                    ]),
            layers: [
            new ol.layer.Tile({
                source: new ol.source.XYZ({
                    attributions: 'Satellite Imagery from Google',
                    url:
                    'http://mt0.google.com/vt/lyrs=s&hl=en&x={x}&y={y}&z={z}',
                    maxZoom: 20,
                    crossOrigin: 'anonymous' // necessary for converting map to img during pdf generation: https://stackoverflow.com/questions/66671183/how-to-export-map-image-in-openlayer-6-without-cors-problems-tainted-canvas-iss
                })}),
                snapshotLayer
            ],
            view: new ol.View({
                center: ol.proj.fromLonLat([0,0]),
                zoom: 1
            })
        });

        // add map data
        function addLayerData(data) {
            feats = new ol.format.GeoJSON().readFeatures(data, {dataProjection: 'EPSG:4326', featureProjection: 'EPSG:3857'});
            // add and zoom the data
            snapshotLayer.getSource().addFeatures(feats);
            map.getView().fit(snapshotLayer.getSource().getExtent());
        };
        let snapshotUrl = "{% url 'api_snapshots' %}?ids=" + snapshotIds.join(',');
        fetch(snapshotUrl).then(resp=>resp.json()).then(data=>addLayerData(data));
        
    }

    function createMapSourceMap(mapId, mapUrl, snapshotIds) {
        // image pixel projection
        const projection = new ol.proj.Projection({
            code: 'pixel-map',
            units: 'pixels',
            extent: [0, 0, 10000, 10000],
        });

        // snapshot layer
        let snapshotLayer = new ol.layer.Vector({
            source: new ol.source.Vector(),
            style: mainGetStyle,
        });

        // map image layer
        let mapLayer = new ol.layer.Image({});
        function setImageSource (url) {
            // clear old source
            mapLayer.setSource();
            if (!url) {
                url = 'https://www.av.se/Static/images/placeholder.png';
            };
            // what to do on image load
            const img = document.createElement('img');
            img.onload = function() {
                // get image extent
                const extent = [0, 0, img.width, img.height];
                // set source
                mapLayer.setSource(
                    new ol.source.ImageStatic({
                        url: url,
                        imageExtent: extent,
                    }),
                );
                // zoom to image extent
                //map.getView().fit(mapLayer.getSource().getImageExtent())
            };
            // begin loading image
            img.src = url;
        };
        setImageSource(mapUrl);

        // map
        let map = new ol.Map({
            target: 'snapshot-map-' + mapId,
            controls: ol.control.defaults().extend([new ol.control.ScaleLine({units: 'metric'}),
                                                    ]),
            layers: [mapLayer,snapshotLayer],
            view: new ol.View({
                projection,
                center: [0,0], //getCenter(extent),
                zoom: 2
            })
        });

        // add map data
        function addLayerData(data) {
            feats = new ol.format.GeoJSON().readFeatures(data, {});
            // add and zoom the data
            snapshotLayer.getSource().addFeatures(feats);
            map.getView().fit(snapshotLayer.getSource().getExtent());
        };
        let snapshotUrl = "{% url 'api_snapshots' %}?ids=" + snapshotIds.join(',');
        fetch(snapshotUrl).then(resp=>resp.json()).then(data=>addLayerData(data));
        
    }

    // get data on startup
    nameList = {{ names|safe }};
    console.log(nameList);
    getTrackData(nameList);

</script>
-->

{% endblock %}
