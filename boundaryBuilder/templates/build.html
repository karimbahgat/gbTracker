{% extends "templates/base.html" %}

{% load static %}

{% block page_content %}

<script src="{% static 'js/ol.js' %}"></script>
<link rel="stylesheet" href="{% static 'css/ol.css' %}" type="text/css">

<script src="{% static 'boundaryBuilder/js/internalSpatial.js' %}"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>

<style>
    #main-section {
        display:flex;
        flex-direction:row;
        gap:10px;
        width:100%;
    }

    #header-div {
        display: flex;
        flex-direction: row;
        width: 100%;
        justify-content: space-between;
    }
    
    .query {
        background-color: lightgray;
        border-radius: 10px;
        padding: 5px;
        min-width: 40px;
        text-align: center;
    }

    #map-div {
        width:100%;
    }
    
    #map {
        width: 100%; 
        height: 400px;
    }

    #sidepanel {
        width:100%;
        height:400px;
    }
    #info-div {
        height:100%;
        margin-bottom:5px;
    }

    #info-div ul {
        list-style-type: none;
    }

    #info-div ul li {
        margin-top: 20px;
    }

    #info-div ul li img {
        height: 25px;
    }

    .time-navbar {
        display: flex; 
        flex-direction: row; 
        width:100%; 
        justify-content:space-between; 
        align-items:center;
    }
    .time-navbar h3 {
        margin: 0;
        padding: 0;
    }

    #events-status {
        width: 100%;
        height: 25px;
    }
    #events-div {
        margin-left: 0px; 
        height: 82%; 
        overflow: auto; 
    }

    .timespan {
        position:absolute;
        background-color:#F0B323; 
        color: white;
        border-radius:5px; 
        padding:10px;
        text-align:center;
        transform:translate(-50%, -100%)%;
        height:10px;
        overflow:hidden;
    }
    .timespan-content {
        display:flex; 
        flex-direction:row; 
        align-items:center; 
        width:100%;
    }
    .timespan:hover {
        cursor:pointer;
    }
    .timespan-current {
        background-color:skyblue; 
        color: white;
        height:100%;
    }
    .timespan-filler {
        color: white;
        border-radius:15px; 
        padding:10px;
        height:10px;
        overflow:hidden;
        margin-bottom:10px;
    }
    .timespan-label {
        margin-right:5px; 
        margin-left:5px;
        vertical-align:middle; 
        white-space:nowrap; 
        overflow:hidden;
    }

    #current-date {
        position:absolute; 
        top:0%; 
        width:5px;
        height:100%;
    }

    #current-date-content {
        background-color:rgb(189, 223, 236); 
        width:100%; 
        height:100%;
        text-align:center; 
        font-weight:bold; 
        font-style:italic;
    }

    #date-labels-div {
        width:100%; 
        background-color:gray;
    }

    .date-label {
        position:absolute; 
        width:fit-content; 
        text-align:center; 
        transform:translate(-50%, -100%);
    }

    .date-label-line {
        position:absolute;  
        top:0%; 
        height:100%; 
        width:1px; 
        background-color:rgb(200,200,200);
    }

    /* history */
    #history-div {
    }

    .history-entry {
        display: flex;
        flex-direction: row;
        gap: 20px;
        width: 100%;
    }

    .history-entry-date {
        display: flex;
        width: 100px;
        height: 100px;
        background-color: lightgray;
        border-radius: 50%;
        justify-content: center;
        align-items: center;
    }

    .history-entry-content {
        min-height: 100px;
        flex-grow: 1;
    }

    .history-entry-content table {
        width: 100%;
    }

    /* changes */
    .change-list {
        margin: 0px;
    }

    .change-entry {
        width: 97%;
        display: flex;
        flex-direction: row;
        margin: 5px;
    }

    .change-type {
        width: 20%;
        background-color: #F0B323;
        color: white;
        border-radius: 5px;
        padding: 3px;
    }

    .change-from {
        width: 40%;
        background-color: lightgray;
        border-radius: 5px;
        padding: 3px;
    }
    .change-to {
        width: 40%;
        background-color: lightgray;
        border-radius: 5px;
        padding: 3px;
    }

    .from-changes-header {
        width: 100%;
        display: flex;
        flex-direction: row;
        padding: 0;
        margin: 0;
        justify-content: space-between;
    }
    .from-changes-header h4 {
        padding: 0;
        margin: 0;
    }

</style>

<section>
    <div class="content">
        <header>
            <div id="header-div">
                <h2 style="flex-shrink:0; margin-right:10px">Build-Your-Own-Boundary: </h2>
                <select id="country-select" onchange="reloadPage()">
                    {% for country in countries %}
                        <option value="{{ country }}" {% if country == current_country %}selected{% endif %}>
                            {{ country }}
                        </option>
                    {% endfor %}
                </select>
                <select id="level-select" onchange="reloadPage()">
                    {% for lvl in levels %}
                        <option value="{{ lvl }}" {% if lvl == current_level %}selected{% endif %}>
                            ADM{{ lvl }}
                        </option>
                    {% endfor %}
                </select>
            </div>
        </header>

        <div id="main-section">
            <div id="map-div">
                <div id="map"></div>
            </div>
            <div id="sidepanel">
                <div id="info-div" class="box">
                    <div class="time-navbar">
                        <button id="prev-button" onclick="prevDate()">ðŸ¡¸</button>
                        <h3 id="timeperiod">XXXX-XX-XX</h3>
                        <button id="next-button" onclick="nextDate()">ðŸ¡º</button>
                    </div>
                    <div id="events-status">
                        Initializing... 
                    </div>
                    <div id="events-div">
                        <!--
                        <div class="change-list">
                            <div class="change-entry">
                                <span class="change-type">Transfer</span>
                                <span class="change-from">From</span>
                                <span class="change-to">To</span>
                                <span><button class="button small">Show</button></span>
                            </div>
                        </div>
                        -->
                    </div>
                </div>
            </div>
        </div>

    </div>
    
    <br>

    <h3>Timeline:</h3>
    
    <div id="timeline">
        <div id="timeline-data" style="width:93%; min-height:80px; margin:4% 4%; position:relative; background-color:whitesmoke; border:rgb(200,200,200) 1px solid">
            <!-- tick date labels -->
            <div class="date-labels-div">
                {% for tick in ticks %}
                <div class="date-label" style="left:{{ tick.percent }}%; right:{{ tick.percent }}%">{{ tick.label }}</div>
                {% endfor %}
            </div>

            <!-- vertical lines at tick dates -->
            {% for tick in ticks %}
                <div style="left:{{ tick.percent }}%; right:{{ tick.percent }}%">
                </div>
            {% endfor %}

            <!-- current time marking (needs to be set with left=...) -->
            <div id="current-date">
                <div id="current-date-content">CURRENT</div>
            </div>

            <!-- all event timespans -->
            <br>
            {% for event in events %}
                <div class="timespan" style="left:{{ event.date_start_perc }}%; width:{{ event.date_dur_perc }}%" title="{{ event.date_start }} &rarr; {{ event.date_end }}">
                    <div class="timespan-content">
                        <!--<img height="20px" src="{% static 'images/time.svg' %}" style="filter:invert(1); vertical-align:middle"/>-->
                        <span class="timespan-label">
                        </span>
                    </div>
                </div>
                <div class="timespan-filler">
                    <!-- since timespans are absolute, need relative divs to fill up the height -->
                </div>
            {% endfor %}
        </div>
    </div>

    <h3>Build History:</h3>

    <div id="history-div">
    </div>

</section>

<br><br>

<script>
    /////////////
    // main map

    // styling
    function getLargestGeom(feature) {
        // create a geometry that defines where the label will be display
        let geom = feature.getGeometry();
        let newGeom;
        if (geom.getType() == 'Polygon') {
            // polygon
            // place label at the bbox/center of the polygon
            let extent = feature.getGeometry().getExtent();
            newGeom = ol.geom.Polygon.fromExtent(extent);
        } else {
            // multi polygon
            // place label at the bbox/center of the largest polygon
            let largestGeom = null;
            let largestArea = null;
            for (let poly of geom.getPolygons()) {
                let extent = poly.getExtent();
                let extentGeom = ol.geom.Polygon.fromExtent(extent);
                let extentArea = extentGeom.getArea();
                if (extentArea > largestArea) {
                    largestGeom = extentGeom;
                    largestArea = extentArea;
                };
            };
            newGeom = largestGeom;
        };
        return newGeom;
    };

    var mainStyle = new ol.style.Style({
        fill: new ol.style.Fill({
            color: 'rgba(220, 220, 255, 0.5)'
        }),
        stroke: new ol.style.Stroke({
            color: 'rgb(29,107,191)',
            width: 2
        })
    });

    var comparisonStyle = new ol.style.Style({
        fill: new ol.style.Fill({
            color: 'rgba(255, 255, 255, 0)', // fully transparent
        }),
        stroke: new ol.style.Stroke({
            color: 'rgba(0, 155, 0, 0.8)',
            width: 1.5,
            lineDash: [10,10]
        }),
    });

    var highlightStyle = new ol.style.Style({
        fill: new ol.style.Fill({
            color: 'rgba(0, 255, 255, 0.5)',
        }),
        stroke: new ol.style.Stroke({
            color: 'rgba(0, 255, 255, 1)',
            width: 3
        }),
    });

    var textStyle = new ol.style.Style({
        text: new ol.style.Text({
            font:'15px sans-serif',
            //overflow:true,
            stroke: new ol.style.Stroke({
                color: 'rgb(255,255,255)',
                width: 2
            })
        }),
        geometry: getLargestGeom
    });

    function mainGetStyle(feature) {
        let _textStyle = textStyle.clone();
        // set name label
        let name = feature.get('fields').names[0].fields.name; // ignore alt names
        _textStyle.getText().setText(name);
        return [mainStyle, _textStyle];
    };

    // layer
    var mainLayer = new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: mainGetStyle,
    });

    var comparisonLayer = new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: comparisonStyle,
    });

    var highlightLayer = new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: highlightStyle,
    });

    // map
    var map = new ol.Map({
        target: 'map',
        controls: ol.control.defaults().extend([new ol.control.FullScreen(),
                                                new ol.control.ScaleLine({units: 'metric'}),
                                                ]),
        layers: [
        new ol.layer.Tile({
            source: new ol.source.XYZ({
                attributions: 'Satellite Imagery from Google',
                url:
                'http://mt0.google.com/vt/lyrs=s&hl=en&x={x}&y={y}&z={z}',
                maxZoom: 20,
                crossOrigin: 'anonymous' // necessary for converting map to img during pdf generation: https://stackoverflow.com/questions/66671183/how-to-export-map-image-in-openlayer-6-without-cors-problems-tainted-canvas-iss
            })}),
            mainLayer,
            comparisonLayer,
            highlightLayer
        ],
        view: new ol.View({
            center: ol.proj.fromLonLat([0,0]),
            zoom: 1
        })
    });

</script>



<script>
    function getMapData(date) {
        queryString = window.location.search;
        queryString += '&model=changeManager.BoundarySnapshot';
        queryString += '&event__date_start__lte='+date;
        queryString += '&event__date_end__gte='+date;
        url = "{% url 'api_filter' %}" + queryString;
        console.log(url)
        fetch(url).then(resp=>resp.json()).then(data=>mapInit(data));
    };

    function boundaryReferenceToProperties(boundaryRef) {
        return boundaryRef;
    };

    function snapshotsToGeoJSON(data) {
        let coll = {type:'FeatureCollection', features:[]}
        for (let snap of data) {
            let geom = snap.fields.geom;
            //geom = cleanGeom(geom);
            let props = boundaryReferenceToProperties(snap.fields.boundary_ref);
            let feat = {type:'Feature', geometry:geom, properties:props, id:props.pk};
            coll.features.push(feat);
        };
        return coll;
    };

    function GeoJSONToFeatures(coll) {
        let feats = new ol.format.GeoJSON().readFeatures(coll, {dataProjection: 'EPSG:4326', featureProjection: 'EPSG:3857'});
        return feats;
    };

    function mapInit(data) {
        console.log(data)
        let coll = snapshotsToGeoJSON(data);
        window.mainData = coll;
        let feats = GeoJSONToFeatures(coll);
        mainLayer.getSource().addFeatures(feats);
        map.getView().fit(mainLayer.getSource().getExtent());
    };

    function updateCurrentBoundaries(coll) {
        window.mainData = coll;
        let feats = GeoJSONToFeatures(coll);
        mainLayer.getSource().clear();
        mainLayer.getSource().addFeatures(feats);
        //map.getView().fit(mainLayer.getSource().getExtent());
    };
</script>



<script>
    // boundary comparison stuff
    function getSnapshotsAtDate(date) {
        // init loading
        initLoading(); 
        // clear previous data
        resetData();
        // define url
        urlParams = new URLSearchParams(window.location.search);
        queryString = '?model=changeManager.BoundarySnapshot';
        for (key of urlParams.keys()) {
            if (key.endsWith('_source')) {continue};
            val = urlParams.get(key);
            queryString += `&${key}=${val}`;
        };
        queryString += '&event__date_start__lte='+date;
        queryString += '&event__date_end__gte='+date;
        url = "{% url 'api_filter' %}" + queryString;
        console.log(url);
        // get snapshots
        fetch(url).then(resp=>resp.json()).then(data=>snapshotsLoaded(data));
    };

    function snapshotsLoaded(data) {
        let coll = snapshotsToGeoJSON(data);
        setComparisonLayer(coll);
        boundaryCompare(coll);
    };

    function initLoading() {
        console.log('init loading')
        // lock the navbar while loading
        loadingLock();
        // update events status
        let status = document.getElementById('events-status');
        status.innerText = 'Loading...'; // indicate loading
    };

    function loadingLock() {
        document.getElementById('prev-button').disabled = true;
        document.getElementById('next-button').disabled = true;
    };

    function resetData() {
        // map layers
        comparisonLayer.getSource().clear();
        highlightLayer.getSource().clear();
        // events table
        div = document.getElementById('events-div');
        div.innerHTML = ''; // clear out
    };

    function setComparisonLayer(coll) {
        comparisonLayer.getSource().clear();
        let feats = GeoJSONToFeatures(coll);
        comparisonLayer.getSource().addFeatures(feats);
    };

    // comparisons
    window.fromChangeData = {}; // this is a global var that gets populated
    
    function boundaryCompare(coll) {
        // this is the main boundary comparison procedure
        console.log(coll);
        let data1 = JSON.stringify(window.mainData);
        let data2 = JSON.stringify(coll);
        // new approach
        // calc only one feat1 at a time (ie feats2 grouped by feat1)
        // at each point return and show results for all feat2 "to" parts that were "from" feat1
        // parts and maps are only showed for the selected feat1
        // eg feat1 may have given two parts to two other boundaries,
        // including a third remaining part belonging to the shape of feat1
        // GOAL: when going through each of the parts in the group, 
        // the goal is to 1) ignore a change if just due to precision,
        // 2) change the "matching" boundary (if the suggested is incorrect)
        window.fromChangeData = {}; // this is a global var that gets populated
        calcAllSpatialRelations(data1, data2, onProgress=onMatchesFound, onSuccess=onMatchesFinished);
        
        // part2: 
        // after all "from" changes have been processed,
        // add groups of feat1 "from" parts belonging to each feat2

        // part3: 
        // detect created or dissolved types by looking for feat1/2 with no match

        // after all "from" and "to" groupings have been processed,
        // should be able to generate the final list of event types,
        // and perform validations
    };

    function lookupBoundary() {
        // search by name or geometry
        // error if couldnt find
        // also change the startdate of the newer boundary / enddate of the older boundary
        return;
    };

    function groupByFromChanges() {
        // 2) Group and union all geom parts by from-boundary
        // for every from-boundary
        // Add what remains of giving province (if anything left/didn't dissolve)
        // ...oldBoundary = ...
        // Union all parts belonging to same fromprov, ie breakaways and parttransfers
        return;
    };

    function groupByToChanges() {
        // 1) Group all entries by to-boundary as list of transfer parts
        // for every to-boundary
        // newBoundary = changes[0].to
        // for each change
        // if change is transfer or merge
        // get part that was transferred
        // change.geometry = turf.intersect(newBoundary.geometry, change.geometry)
        // subtract that part from the newer boundary
        // newBoundary.geometry = turf.difference(newBoundary.geometry, change.geometry)
        // or if change is splitpart
        // the whole thing used to be part of an older prov
        // ...and so should just be unioned as it is
        // parts.push(change)
        
        // If newinfo is the only change
        // changes[0].geometry = newBoundary.geometry
        // parts.push(changes[0])
        
        // If transfer or merge
        // If has "created" type, trim off all received parts
        // ...and check to make sure there's nothing left of newBoundary
        // If does not have "created" type, make sure there's still something left
        // ...ie it already existed prior to the changes.
        // ...AND add extra prov how it looked before
        // - apply any info changes
        // - parts.push(trimmedBoundary)
        return;
    };

    function applyReverseBoundaryChanges() {
        // 1) Group all entries by to-boundary as list of transfer parts
        // 2) Group and union all geom parts by from-boundary
        // 3) Add to final data? 
        // 4) Maybe change all remaining provs via * (parent change)
        return;
    };

    function groupBy(items, keyFunc) {
        // brute force, not very effective
        let keys = {};
        for (let item of items) {
            key = keyFunc(item);
            keys[key] = null;
        };
        keys = Object.keys(keys);
        keys.sort();
        let groups = [];
        for (let key of keys) {
            let group = [];
            for (let item of items) {
                if (keyFunc(item) == key) {
                    group.push(item);
                };
            };
            groups.push([key,group]);
        };
        return groups;
    };

    function applyForwardBoundaryChanges() {
        console.log('applying forward boundary changes')

        // 1) Group all entries by from-boundary as list of transfer parts
        console.log('getting all intersection parts')
        let allParts = [];
        console.log(window.fromChangeData)
        for (let f1 of window.mainData.features) {
            let id = f1.properties.pk;
            console.log(id);
            if (window.fromChangeData.hasOwnProperty(id)) {
                // changes
                let changes = window.fromChangeData[id][1];
                let parts = getIntersectionParts(f1, changes);
                for (let part of parts) {
                    allParts.push(part);
                };
            } else {
                // no change
                let part = {type:'Same', // just a temporary type name
                            from:f1.properties,
                            to:f1.properties,
                            geometry:f1.geometry}
                allParts.push(part);
            };
        };
        console.log(allParts)
        if (allParts.length == 0) { return };

        // 2) Group and union all geom parts by to-boundary
        console.log('unioning all intersection parts')
        function keyFunc(part) {
            return part.to.fields.names[0].fields.name;
        };
        let groups = groupBy(allParts, keyFunc);
        let feats = [];
        for (let [key,groupParts] of groups) {
            console.log(key)
            console.log(groupParts)
            let geoms = [];
            for (let part of groupParts) {
                geoms.push(part.geometry);
            };
            let union = getUnion(geoms);
            //union = cleanGeom(union);
            let props = groupParts[0].to; // just a copy for now
            let feat = {type:'Feature',
                        id:props.pk, // need a better id probably
                        properties:props,
                        geometry:union};
            feats.push(feat);
        };

        // 3) Update the map boundaries
        let coll = {type:'FeatureCollection',
                    features:feats};
        console.log(coll)
        updateCurrentBoundaries(coll);
    };

    function applyReverseBoundaryChanges() {
        console.log('applying reverse boundary changes')
        // WARNING! doesnt quite work yet...
        // tried to reverse the logic from applyForward...
        // but definitely contains errors/typos from porting...

        // reorganize into tochangedata
        let toChangeData = {};
        let allChanges = [];
        for (let id of Object.keys(window.fromChangeData)) {
            let [f1,changes] = window.fromChangeData[id];
            for (let change of changes) {
                allChanges.push(change);
            };
        };
        function keyFunc(change) {
            return change.to.fields.pk;
        };
        let groups = groupBy(allChanges, keyFunc);
        for (let [id,groupChanges] of groups) {
            console.log(id)
            console.log(groupChanges)
            toChangeData[id] = groupChanges;
        };

        // 1) Group all entries by to-boundary as list of transfer parts
        console.log('getting all intersection parts')
        let allParts = [];
        console.log(toChangeData)
        for (let f1 of window.mainData.features) {
            let id = f1.properties.pk;
            console.log(id);
            if (toChangeData.hasOwnProperty(id)) {
                // changes
                let changes = toChangeData[id];
                let parts = getIntersectionParts(f1, changes);
                for (let part of parts) {
                    allParts.push(part);
                };
            } else {
                // no change
                let part = {type:'Same', // just a temporary type name
                            from:f1.properties,
                            to:f1.properties,
                            geometry:f1.geometry}
                allParts.push(part);
            };
        };
        console.log(allParts)
        if (allParts.length == 0) { return };

        // 2) Group and union all geom parts by from-boundary
        console.log('unioning all intersection parts')
        function keyFunc(part) {
            return part.from.fields.names[0].fields.name;
        };
        groups = groupBy(allParts, keyFunc);
        let feats = [];
        for (let [key,groupParts] of groups) {
            console.log(key)
            console.log(groupParts)
            let geoms = [];
            for (let part of groupParts) {
                geoms.push(part.geometry);
            };
            let union = getUnion(geoms);
            //union = cleanGeom(union);
            let props = groupParts[0].from; // just a copy for now
            let feat = {type:'Feature',
                        id:props.pk, // need a better id probably
                        properties:props,
                        geometry:union};
            feats.push(feat);
        };

        // 3) Update the map boundaries
        let coll = {type:'FeatureCollection',
                    features:feats};
        console.log(coll)
        updateCurrentBoundaries(coll);
    };

    function onMatchesFound(i, total, f1, related) {
        // this processes all feat2 matches found for one particular feat1
        console.log(`${i} of ${total} processed`);
        console.log(f1);
        // sort by equality
        related = sortSpatialRelations(related, 'equality', 0.0);
        // add to fromChangeData
        let entries = [];
        for (let [f2,stats] of related) {
            if (stats.equality >= 0.99) { continue }; // near duplicate
            if (stats.within < 0.05) { continue }; // barely overlapping
            console.log(stats);
            console.log(f2);
            // determine change entry
            let changeType = 'Transfer';
            let entry = {type:changeType,
                        from:f1.properties,
                        to:f2.properties,
                        fromgeom:null, // should be f1.geometry, but not needed during forward building
                        togeom:f2.geometry,
                        stats:stats,
                        id:null, //changeData.length+1,
                        };
            entries.push(entry);
            console.log(entry);
        };
        // add to table
        if (entries.length > 0) {
            window.fromChangeData[f1.id] = [f1,entries];
            addFromChangesTable(f1, entries);
        };
    };

    function onMatchesFinished() {
        let div = document.getElementById('events-div');
        let status = document.getElementById('events-status');
        if (div.innerHTML == '') {
            // no changes detected
            console.log('no changes...')
            status.innerText = 'No changes detected for this date';
        } else {
            // loading finished and succeded
            status.innerText = `Found ${Object.keys(window.fromChangeData).length} boundaries with changes`; 
        };
        // turn back on nav buttons
        updateNavButtons(currentDate);
    };

    function showFromMatchGroup(id) {
        // this gets called when clicking a particular from-group
        // clear any existing highlight
        highlightLayer.getSource().clear();
        // get features
        console.log('should show from group');
        console.log(id);
        let [f1,entries] = window.fromChangeData[id];
        let f1geom = cleanGeom(f1);
        //let feat1 = mainLayer.getSource().getFeatureById(f1.properties.pk);
        for (entry of entries) {
            let f2 = entry.to;
            let f2geom = entry.togeom;
            f2geom = cleanGeom(f2geom);
            //let feat2 = comparisonLayer.getSource().getFeatureById(f2.pk);
            // calc isec
            let isec;
            try {
                isec = geomIntersection(f1geom, f2geom);
            } catch(err) {
                console.warn('intersect error: '+err);
                continue;
            };
            if (isec == null) {
                continue;
            };
            // add to map
            let feat = new ol.format.GeoJSON().readFeature(isec, {dataProjection: 'EPSG:4326', featureProjection: 'EPSG:3857'});
            //feat.setId(id);
            //highlightLayer.getSource().addFeature(feat1);
            //highlightLayer.getSource().addFeature(feat2);
            highlightLayer.getSource().addFeature(feat);
        };
        // zoom
        //zoomToFeat(mainLayer, id);
        // dehighlight after x time
        setTimeout(function() {
            highlightLayer.getSource().clear();
            }, 
            1000 // 1 seconds
        );
    };

    function zoomToFeat(lyr, id) {
        let feat = lyr.getSource().getFeatureById(id);
        map.getView().fit(feat.getGeometry().getExtent(),
                          {'duration':500, 'padding':[10,10,10,10]}
        );
    };

    function addFromChangesTable(f1, changes) {
        // add group containing list of each detected change event in the right panel
        div = document.getElementById('events-div');
        groupDiv = document.createElement('div');
        groupDiv.className = 'from-changes';
        div.appendChild(groupDiv);
        // header row
        header = document.createElement('div');
        header.className = 'from-changes-header';
        groupDiv.appendChild(header);
        // header title
        obj = document.createElement('h4');
        obj.innerText = `From: ${f1.properties.fields.names[0].fields.name}`;
        header.appendChild(obj);
        // buttons div
        buttons = document.createElement('div');
        header.appendChild(buttons);
        // zoom button
        obj = document.createElement('button');
        obj.className = 'button small';
        obj.innerText = 'Show';
        let id = f1.id;
        obj.onclick = function() {showFromMatchGroup(id)};
        buttons.appendChild(obj);
        // loop changes
        changeEntries = document.createElement('div');
        changeEntries.className = 'change-list';
        groupDiv.appendChild(changeEntries);
        for (change of changes) {
            //console.log(change);
            // entry
            entry = document.createElement('div');
            entry.className = 'change-entry';
            changeEntries.appendChild(entry);
            // type
            obj = document.createElement('span');
            obj.className = 'change-type';
            obj.innerText = change.type;
            entry.appendChild(obj);
            // from
            obj = document.createElement('span');
            obj.className = 'change-from';
            obj.innerText = change.from.fields.names[0].fields.name;
            entry.appendChild(obj);
            // to
            obj = document.createElement('span');
            obj.className = 'change-to';
            let perc = (change.stats.within*100).toFixed(0);
            obj.innerText = change.to.fields.names[0].fields.name + ` (${perc}%)`;
            entry.appendChild(obj);
        };
        // group separator
        obj = document.createElement('br');
        groupDiv.appendChild(obj);
    };
</script>



<script>
    function addHistoryEntry() {
        if (Object.keys(window.fromChangeData).length == 0) {
            return;
        };
        let date = currentDate;
        let div = document.createElement('div');
        div.className = 'history-entry';
        div.innerHTML = `
            <h3 class="history-entry-date">
                ${date}
            </h3>
            <div class="history-entry-content box">
            </div>
        `;
        document.getElementById('history-div').prepend(div);
        let content = div.querySelector('.history-entry-content');
        for (let key of Object.keys(window.fromChangeData)) {
            let changes = window.fromChangeData[key][1];
            for (change of changes) {
                console.log(change)
                let entry = document.createElement('div');
                entry.className = 'change-entry';
                entry.innerHTML = `
                    <span class="change-type">
                    ${change.type}
                    </span>
                    <span class="change-from">
                    ${change.from.fields.names[0].fields.name}
                    </span>
                    <span class="change-to">
                    ${change.to.fields.names[0].fields.name}
                    </span>
                `;
                content.appendChild(entry);
            };
        };
    };
</script>



<script>
    // save all events for future use
    events = [];
    {% for event in events %}
        event = {};
        event['date_start'] = "{{ event.date_start }}";
        event['date_end'] = "{{ event.date_end }}";
        events.push(event);
    {% endfor %}

    // turn into unique dates
    dates = {};
    for (event of events) {
        dates[event.date_start] = true;
        dates[event.date_end] = true;
    };
    dates = Object.keys(dates);

    // find total span in ms
    dates.sort();
    minDateNum = Date.parse(dates[0]);
    maxDateNum = Date.parse(dates[dates.length-1]);
    dateSpanNum = maxDateNum - minDateNum;
    
    // function to convert dates to percent
    function getDatePercent(date) {
        num = Date.parse(date);
        frac = (num - minDateNum) / dateSpanNum;
        return frac * 100.0;
    };

    // functions to set dates
    currentDate = events[0].date_start;
    
    function setCurrentDate(date) {
        perc = getDatePercent(date);
        document.getElementById('current-date').style.left = perc + '%';
        document.getElementById('timeperiod').innerText = date;
        updateNavButtons(date);
        getSnapshotsAtDate(date);
    };

    function findPrevDate(date) {
        // finds previous end-date
        for (let i=events.length-1; i >= 0; i--) {
            let event = events[i];
            if (event.date_end < date) {
                return event.date_end;
            };
        };
        // otherwise jump to first date
        return events[0].date_start;
    };

    function findNextDate(date) {
        // finds next start-date
        for (let event of events) {
            if (event.date_start > date) {
                return event.date_start;
            };
        };
        // otherwise jump to last date
        return events[events.length-1].date_end;
    };

    function prevDate() {
        currentDate = findPrevDate(currentDate);
        setCurrentDate(currentDate);
        applyReverseBoundaryChanges();
    };

    function nextDate() {
        currentDate = findNextDate(currentDate);
        setCurrentDate(currentDate);
        applyForwardBoundaryChanges();
        addHistoryEntry();
    };

    // function to update navigation buttons
    function updateNavButtons(currentDate) {
        prevBut = document.getElementById('prev-button');
        nextBut = document.getElementById('next-button');
        // enable/disable previous button
        if (currentDate == dates[0]) {
            prevBut.disabled = true;
        } else {
            prevBut.disabled = false;
        };
        // enable/disable next button
        if (currentDate == dates[dates.length-1]) {
            nextBut.disabled = true;
        } else {
            nextBut.disabled = false;
        };
    };

    // init main map
    getMapData(currentDate);

    // init current date
    setCurrentDate(currentDate);
</script>

<script>
    function reloadPage() {
        let country = document.getElementById('country-select').value;
        let level = parseInt(document.getElementById('level-select').value);
        let paramParts = ['boundary_ref'];
        for (let i=0; i<level; i++) {
            console.log(i)
            paramParts.push('parent');
        };
        paramParts.push('names__name');
        let paramName = paramParts.join('__');
        let queryString = '?' + paramName + '=' + country;
        let url = "{% url 'build' %}" + queryString;
        console.log(url);
        window.location.href = url;
    };
</script>


{% endblock %}
